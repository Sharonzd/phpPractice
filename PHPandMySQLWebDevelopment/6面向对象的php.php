<?php
/**
 * File:
 * Auther: zhoudan03
 * Datetime: 16/8/16 13:12
 */
//类
class Page
{

//    类的属性
    public $content;

    //public可以在类的内部或外部进行访问
    public $public = "public attribute<br>";
    //private 只能在类的内部进行访问,不会被子类继承
    private $private = "private attribute<br>";
    //protected只能在类内部访问,也存在于任何子类
    protected $protected = "protected attribute<br>";

//    构造函数,对象被创建的时候自动被调用
    function __construct()
    {
        echo "parent construct called"."<br>";
    }

//    析构函数
    function __destruct()
    {
        echo "parent destruct called<br>";
        // TODO: Implement __destruct() method.
    }

//    访问函数, 给private属性 和 protected属性提供访问的入口
    function __get($name)
    {
        echo "__get called<br>";
        // TODO: Implement __get() method.
        return $this->$name;   ///作为一个参数,仍然保留$以便和参数名称一致
    }
//设置属性的函数
    function __set($name, $value)
    {
        // TODO: Implement __set() method.
        echo "__set called<br>";
        $this->$name = $value;
    }

    function __clone()
    {
        echo "Page __clone called<br>";
        // TODO: Implement __clone() method.
    }

//    使用final关键字禁止方法被重载
    final function final_operation(){
        echo "parent final_operation called<br>";
    }

    //    类的操作函数
    private function private_operation($param){
//        $this 可以访问当前的类
//        通过$this 访问当前类的变量时,不需要$
        echo "parent private_operation called<br>";
    }

    protected function protect_operation(){
        echo "parent protect_operation called<br>";
    }

    public function public_operation(){
        echo "parent public_operation called<br>";
    }

///echo '-----------------------__call重载方法-------------------------'."<br>";
///__call带有两个参数, 被调用的方法名称, 传递给该方法的参数数组。根据参数不同决定调用的方法。

//    public function display(){
//
//    }
    public function __call($method,$p){
        if($method == 'display'){
//            在这儿,根据不同的参数,可以调用不同的方法
            if(is_object($p[0])){
                echo '111';
//                $this->public_operation();
            }else if(is_array($p[0])){
                echo '222';
//                $this->final_operation();
            }else{
                echo '333';
//                $this->protect_operation();
            }
    }
    }
}

$page = new Page();  //实例化的时候,会调用构造函数
echo $page ->public;  // 用->访问public属性的时候, ->一定要紧接着属性名,  属性名不要$  此时不会调用__get
echo "<br>";
echo $page->protected;//用实例->访问protected属性的时候, 会调用__get
echo "<br>";
echo $page ->private; //用->访问private属性的时候, 会调用__get
echo "<br>";
$page ->public = 'new public attribute<br>'; //设置public属性时候, 不会调用__set.
echo $page->public;
echo "<br>";
$page->protected = "new protected attribute<br>"; //设置protected的时候, 间接会调用__set
echo $page->protected;
echo "<br>";
$page->private="new private attribute<br>"; //设置private的时候,间接调用__set
echo $page ->private;         //获取属性的时候, 间接会调用__get


echo '-----------------------__call重载方法-------------------------'."<br>";
//不用实现任何display()方法
echo "<br>";
$page->display(array(1,2,3));
echo 'he11111';
$page->display('cat');

echo "<br>";
//继承, 每个类最多继承一个父类。
class ServicePage extends Page{
    private $row2buttons = array();

    function __construct()
    {
        echo "__construct called"."<br>";
        parent::__construct();///调用父类的construct
        //$this->private_operation();  //父类的私有方法不允许访问
        $this->protect_operation();     //父类的protect方法也被继承过来了
    }

//    function final_operation(){    ///不允许重载父类的  final方法
//        echo "son final operation";
//    }


//重载父类的方法
    public function public_operation()
    {
        parent::public_operation(); // TODO: Change the autogenerated stub
        echo "self public operation called<br>";
    }

//    不写的话,默认直接继承父类的析构函数
    function __destruct()
    {
        echo "self destruc called<br>";
        // TODO: Implement __destruct() method.
    }
}

$services = new ServicePage();  //实例化的时候construct被调用

$services->final_operation();
$services->public_operation();   //父类的public方法被继承过来了
//$services->protect_operation();  ///protected 只允许在类里面访问。

echo '--------------------interface----------------------------'."<br>";
interface Interface1{
    function display();
}

interface Interface2{
    function disaplay2();
}

//webpgage类可以继承一个类,同时可以实现多个接口
class Webpage extends Page implements Interface1, Interface2{
//    类必须要实现接口的方法。
    function display()
    {
        // TODO: Implement display() method.
    }
    function disaplay2()
    {
        // TODO: Implement disaplay2() method.
    }
}
$webpage = new Webpage();

echo '-----------------------per-class常量-------------------------'."<br>";
class Math{
    /*per-class常量, 不需要初始化该类, 便可以用::来访问*/
    const pi = 3.14159;
    /*static静态方法,允许在未初始化类的情况下调用, 不能用this,因为没有可以引用的对象实例*/
    static function squared($input){
        return $input*$input;
    }
}
echo "Math::pi = ".Math::pi."<br>";
echo "Math::squared(8) = ".Math::squared(8)."<br>";


echo '-----------------------instanceof-------------------------'."<br>";
//检查一个对象是否是一个特定的类的实例、是否是从某个类继承过来、是否实现了某个接口
echo $services instanceof ServicePage;
echo "<br>";
echo $services instanceof Page;
echo "<br>";
echo $webpage instanceof Interface1;
echo "<br>";

echo '-----类的类型提示,在函数的参数里指定必须传入的参数类类型-------------------------'."<br>";
function check_hint(Page $someclass){
echo "get instance of page";
}
$math = new Math();
//check_hint($math);  会产生错误,要求必须是类Page的实例
check_hint($services);


echo "<br>";
echo '-----------------------延迟静态绑定-------------------------'."<br>";
//允许在一个静态继承的上下文中 对一个被调用类的引用。父类可以使用子类重载的静态方法。
class A{
    public static function who(){
        echo __CLASS__;
    }
    public static function test(){
        static::who();  //延迟静态绑定
    }
}

class B extends A{
    public static function who(){
        echo __CLASS__;
    }
}

B::test();  //继承了A的test,而test调用who

//无论类是否被重载,允许在运行时调用类的引用都很棒
echo "<br>";

echo '-----------------------克隆对象-------------------------'."<br>";
$c = clone $services;  //具有相同类的副本,相同的属性值.  在基类（Page）中创建__clone方法,会再被clone的时候被调用。可以用来定义确切的复制行为。

echo '-----------------------抽象类,抽象方法-------------------------'."<br>";
//用于复杂的类层次关系,确保没一个子类都包含并重载了某些特定的方法。不过这也可以通过接口来实现
abstract class AbstractClass{
    abstract function abstract_operation($param1,$param2);
}

echo '-----------------------__autoload()-------------------------'."<br>";
////是一个单独的函数,可以在任何类声明之外声明此函数。 将在实例化一个还没有被声明的类时自动调用。
///一般用来包含或请求需要的类的类文件。
function __autoload($name){
    include_once $name.".php";
}

echo '-----------------------实现迭代器和迭代-------------------------'."<br>";
/*ObjectIterator类具有Iterator接口所要求的一系列函数*/
class ObjectIterator implements Iterator{
    private $obj;
    private $count;
    private $currentIndex;

    ///构造函数并不是必须的,但是它是设置将要迭代的项数和当前数据项链接的地方
    function __construct($obj)
    {
        $this->obj = $obj;
        $this->count = count($this->obj->data);
    }

    ///rewind函数将内部数据指针设置回数据开始处
    function rewind()
    {
        $this->currentIndex = 0;
        // TODO: Implement rewind() method.
    }
    ///valid判断数据指针的当前位置是否还有更多数据
    function valid()
    {
        return $this->currentIndex < $this->count;
        // TODO: Implement valid() method.
    }
    ///返回数据指针的值
    function key()
    {
        return $this->currentIndex;
        // TODO: Implement key() method.
    }
//    在数据中移动数据指针的值
    function next()
    {
        $this->currentIndex++;
        // TODO: Implement next() method.
    }
//    返回保存在当前数据指针的值
    function current()
    {
        return $this->obj->data[$this->currentIndex];
        // TODO: Implement current() method.
    }

}

class Object implements IteratorAggregate{
    public $data = array();
    function __construct($in)
    {
        $this->data = $in;
    }

    function getIterator()
    {
        return new ObjectIterator($this);
        // TODO: Implement getIterator() method.
    }
}

$myObject = new Object(array(2,4,6,8,10));
$myIterator = $myObject->getIterator();
for ($myIterator->rewind();$myIterator->valid();$myIterator->next()){
    $key = $myIterator->key();
    $value = $myIterator->current();
    echo $key." => ".$value."<br>";
}


echo '-----------------------将类转换为字符串-------------------------'."<br>";
$newpage = new Printable;   //
echo $newpage;
class Printable{
    public $testone;
    public $testtwo;
    public $testthree;
    //必须要对类实现 __toString方法,才能打印实例
    public function __toString()
    {
//        var_export打印类中的所有属性值。
        return var_export($this,TRUE);
        // TODO: Implement __toString() method.
    }
}
echo "<br>";

echo '-----------------------使用Reflection反射-------------------------'."<br>";
//反射是通过已有类和对象来找到类和对象的结构和内容的能力。适用于 使用未知或文档不详或者已经被编译的看不出原形的php脚本的时候
$class = new ReflectionClass("Page");
echo "<pre>".$class."</pre>";  //使用了reflection的__toString();   <pre>能使得换行
//echo $class;